#!#include "utilities.hpp"
#!#include "symbolic.hpp"
#!#include "coptgen.hpp"
#!#include "formatter.hpp"
#!#include "preprocess.hpp"
#!#include "linearalgebra.hpp"
#!#include <iostream>
#!#include <iomanip>
#!#include <fstream>
#!#include <sstream>
#!#include <set>
#!#include <assert.h>
#!
#!using namespace std;
#!using namespace utilities;
#!using namespace symbolic;
#!
#!namespace preprocess {
#!
#!class CudaCodeGenerator : public CodeGenerator {
#!public:
#!
#!  LinearAlgebra linearAlgebra;
#!  symbolic::Format *format_precision;
#!
#!  string file;
#!  string prefix;
#!  string precision;
#!  string type;
#!  size_t dim;
#!  enum { SOURCE=0x01, HEADER=0x02, CUDA_HEADER=0x04 };
#!  int mode;
#!
#!  std::string format(const std::string &s) const { 
#!    symbolic::Expression *e=parse(s);
#!    std::ostringstream oss;
#!    oss << format(e);
#!    delete e;
#!    return oss.str();
#!  }
#!
#!  symbolic::FormatResult format ( const symbolic::Expression * e ) const {
#!    return format_precision(e);
#!  }
#!
#!  void configure(Configuration *_configuration) {
#!    CodeGenerator::configure(_configuration);
#!
#!    file=flag("file");
#!    mode=0;
#!
#!    if (endswith(file,".cu")) {
#!      mode |= SOURCE;
#!    }
#!
#!    if (endswith(file,".hu")) {
#!      mode |= CUDA_HEADER;
#!    }
#!
#!    if (endswith(file,".h")) {
#!      mode |= HEADER;
#!    }
#!
#!    if (!mode) {
#!      mode = SOURCE | HEADER | CUDA_HEADER;
#!    }
#!
#!    if ((mode & SOURCE) != 0) {
#!      configuration->flags["is_source"]="true";
#!    }
#!
#!    if ((mode & HEADER) != 0 || (mode & CUDA_HEADER) != 0) {
#!      configuration->flags["is_header"]="true";
#!    }
#!
#!    prefix=flag("prefix");
#!    precision=flag("precision");
#!
#!    if (precision == "single") {
#!      type="float";
#!      format_precision=&symbolic::format_c_single;
#!    } else if (precision == "double") {
#!      type="double";
#!      format_precision=&symbolic::format_c_double;
#!    } else {
#!      cerr << "cppcodegenerator: unsupported precision " << encode_string(precision) << endl;
#!      return;
#!    }
#!
#!    configuration->flags["type"]=type;
#!
#!    dim=nequations();
#!    linearAlgebra.generator=this;
#!    linearAlgebra.configure();
#!  }
#!
#!  void begin_namespace()
#!  {
#!    if (flag("namespace") != "") {

namespace $(flag("namespace")) {

#!      indent +=2;
#!    }
#!  }
#!
#!
#!  void end_namespace()
#!  {
#!    if (flag("namespace") != "") {
#!      indent -=2;

} // namespace $(flag("namespace"))

#!    }
#!  }
#!
#!  void define_inline()
#!  {
//
// equivalent to int(ceil(float(a)/float(b)))
//
static inline int ceildiv(int a, int b) {
  return (a/b)+((a % b) != 0);
}

#!  }
#! 
#!  void prototype_device_function(const std::string &end="")
#!  {
__device__ void $(prefix)f(
  int $(prefix)chunk,
  int $(prefix)cell,
  const $(type) $(prefix)globals[$(nglobals())],
  $(type) *$(prefix)parameters,
  const $(type) *$(prefix)x,
  $(type) *$(prefix)y
)$(end)
#!  }
#!
#!  void define_device_function()
#!  {
#!prototype_device_function();
{
#!    if (flag("coptgen")=="true") {
#!      COptGen coptgen;
#!      coptgen.type=type;
#!      coptgen.format=format_precision;
#!      FOREACH_EQUATION(i) {
#!        coptgen.assign(i->first,i->second);
#!      }
#!      coptgen.print(*out);
#!    } else {
#!      FOREACH_EQUATION(i) {
  // $(i->first)=$(i->second);
  $(format(i->first))=$(format(i->second));
#!      }
#!    }
} // device $(prefix)f()
#!  } // define_device_function
#!
#!  void prototype_scalar_function(const std::string &end="")
#!  {
#!    if (unchecked_parameter_index_of("scalar_residual") != -1) {
void $(prefix)scalarf(
  int $(prefix)chunk,int $(prefix)cell,
  const $(type) $(prefix)globals[$(nglobals())],
  $(type) *$(prefix)parameters,
  const $(type) *$(prefix)x,
  $(type) *$(prefix)y
)$(end)
#!    }
#!  }
#!
#!  void define_scalar_function()
#!  {
#!    if (unchecked_parameter_index_of("scalar_residual") != -1) {
#!prototype_scalar_function();
{
#!    if (flag("coptgen")=="true") {
#!      COptGen coptgen;
#!      coptgen.type=type;
#!      coptgen.format=format_precision;
#!      FOREACH_EQUATION(i) {
#!        coptgen.assign(i->first,i->second);
#!      }
#!      coptgen.print(*out);
#!    } else {
#!      FOREACH_EQUATION(i) {
  // $(i->first)=$(i->second);
  $(format(i->first))=$(format(i->second));
#!      }
#!    }
} // $(prefix)scalarf()
#!  }
#!  } // define_scalar_function
#!
#!  void prototype_global_function(const std::string &end="")
#!  {
__global__ void $(prefix)cuda_f(int chunk, int n,
  const $(type) *globals,
  $(type) *parameters,
  const $(type) *x,
  $(type) *y
)$(end)
#!  }
#!
#!  void define_global_function()
#!  {
#!prototype_global_function();
{
  int i = blockIdx.x*blockDim.x + threadIdx.x;
  if (i < n) {
    $(prefix)f(chunk,i,globals,&parameters[0],&x[0],&y[i*$(nequations())]);
  }
} // __global__ $(prefix)cuda_f()
#!  }
#!
#!  void prototype_host_function(const std::string &end="")
#!  {
void $(prefix)f(
  const $(type) *globals,
  int n,
  $(type) *parameters,
  const $(type) *x,
  $(type) *y
)$(end)
#!  }
#!
#!  void define_host_function()
#!  {
#!prototype_host_function();
{
#! int blocksize_index=unchecked_global_index_of("blocksize");
#! if (blocksize_index != -1) {
  int blocksize=int(globals[$(blocksize_index)]);
#! } else {
  int blocksize=240;
#! }

#! int chunk_index=unchecked_global_index_of("chunk");
#! if (chunk_index != -1) {
  int chunk=int(globals[$(chunk_index)]);
#! } else {
  int chunk=100*blocksize;
#! }
  if (chunk > n) chunk=n;
  Vec<$(type)> vecglobals($(nglobals()),blocksize);
  Vec<$(type)> vecparameters($(nparameters())*chunk,blocksize);
  Vec<$(type)> vecx($(nvariables())*chunk,blocksize);
  Vec<$(type)> vecy($(nequations())*chunk,blocksize);

  for (int k=0; k<$(nglobals()); ++k) vecglobals[k]=globals[k];
  for (int k=0; k<n; k+=chunk) {
    int m=chunk;
    if (k+m > n) m=n-k;
    for (int el=0; el<m; ++el) {
       for (int elp=0; elp<$(nparameters()); ++elp) { vecparameters[$(nparameters())*el+elp]=parameters[$(nparameters())*(k+el)+elp]; }
       for (int elx=0; elx<$(nvariables()); ++elx) { vecx[$(nvariables())*el+elx]=x[$(nvariables())*(k+el)+elx]; }
       for (int ely=0; ely<$(nequations()); ++ely) { vecy[$(nequations())*el+ely]=y[$(nequations())*(k+el)+ely]; }
    }
    dim3 block(blocksize,1,1);
    dim3 grid(ceildiv(m,blocksize),1,1);
    $(prefix)cuda_f<<<grid,block>>>(chunk,m,vecglobals.dev_data(),vecparameters.dev_data(),vecx.dev_data(),vecy.dev_data());    
    cutilSafeCall(cudaThreadSynchronize());
    for (int el=0; el<m; ++el) {
       for (int ely=0; ely<$(nequations()); ++ely) { y[$(nequations())*(k+el)+ely]=vecy[$(nequations())*el+ely]; }
    }
  }
} // $(prefix)f()
#!  } // define_function
#!
#!  void prototype_device_jacobian(const std::string &end="")
#!  {
#!
__device__ void $(prefix)df(
  int $(prefix)chunk,int $(prefix)cell,
  const $(type) $(prefix)globals[$(nglobals())],
  $(type) *$(prefix)parameters,
  const $(type) *$(prefix)x,
  $(type) *$(prefix)dy
)$(end)
#!  }
#!
#!  void define_device_jacobian()
#!  {
#!prototype_device_jacobian();
{
#!    if (flag("coptgen")=="true") {
#!      COptGen coptgen;
#!      coptgen.type=type;
#!      coptgen.format = format_precision;
#!      FOREACH_EQUATION(i) {
#!        Expression *ri=parse(i->first);
#!        Expression *yi=parse(i->second);
#!        FOREACH_VARIABLE(j) {
#!          Expression *xj=parse(*j);
#!          Expression *dyi_dxj=differentiate(yi,*j);
#!          std::ostringstream oss;
#!          oss << "d" << format(ri) << "_d" << format(xj);
#!          std::string dydx= oss.str();
#!          coptgen.assign(dydx,dyi_dxj);
#!          delete dyi_dxj;
#!          delete xj;
#!        }
#!        delete yi;
#!        delete ri;
#!      }
#!      coptgen.print(*out);
#!    } else {
#!      FOREACH_EQUATION(i) {
#!        Expression *ri=parse(i->first);
#!        Expression *yi=parse(i->second);
#!        FOREACH_VARIABLE(j) {
#!          Expression *xj=parse(*j);
#!          Expression *dyi_dxj=differentiate(yi,*j);
  d$(format(ri))_d$(format(xj))=$(format(dyi_dxj));
#!          delete dyi_dxj;
#!          delete xj;
#!        }
#!        delete yi;
#!        delete ri;
#!      }
#!    }
} // $(prefix)df()
#!  } // define device jacobian
#!
#!  void prototype_device_initialize(const std::string &end="")
#!  {
__device__ void $(prefix)initialize(
  int $(prefix)chunk,int $(prefix)cell,
  const $(type) $(prefix)globals[$(nglobals())],
  $(type) *$(prefix)parameters,
  $(type) *$(prefix)x
)$(end)
#!  }
#!
#!  void define_device_initialize()
#!  {
#!prototype_device_initialize();
{
  // initialize unknowns from parameters
#!FOREACH_INITIALIZER(k) {
  // $(k->first)=$(k->second);
  $(format(k->first))=$(format(k->second));
#!}
} // $(prefix)initialize()
#!  }
#!
#!  void prototype_device_solve(const std::string &end="")
#!  {
__device__ void $(prefix)solve(
  int chunk,int cell,
  const $(type) globals[$(nglobals())],
  $(type) *parameters,
  $(type) *x
)$(end)
#!  }
#!
#!  void define_device_solve()
#!  {
#!    string target="__device__";
#!    string cudaprefix="cuda";
#!    string solver=flag("solver","newton");
#!    string cuda_declare_args="int chunk,int cell,";
#!    string cuda_args="chunk,cell,";
#!    if (solver=="newton") {
#!#include "../tmp/solve_newton.cpp"
#!    }
#!    if (solver=="damped_newton") {
#!#include "../tmp/solve_damped_newton.cpp"
#!    }
#!    if (solver=="empty") {
#!#include "../tmp/solve_empty.cpp"
#!    }
#!  }
#!
#!  void prototype_global_solve(const std::string &end="")
#!  {
__global__ void $(prefix)cuda_solve(int chunk,const $(type) *globals,int n, $(type) *parameters,$(type) *x)$end
#!  }
#!
#!  void define_global_solve()
#!  {
#!    prototype_global_solve();
{
  int i = blockIdx.x*blockDim.x + threadIdx.x;
  if (i < n) {
    $(prefix)solve(chunk,i,globals,parameters,x);
  }
} // __global__ $(prefix)cuda_solve
#!  }
#!
#!  void prototype_host_solve(const std::string &end="")
#!  {
void $(prefix)solve(
  const $(type) *globals,
  int n,
  $(type) *parameters,
  $(type) *x
)$(end)
#!  }
#!
#!  void define_host_solve()
#!  {
#!     prototype_host_solve();
{
#! int blocksize_index=unchecked_global_index_of("blocksize");
#! if (blocksize_index != -1) {
  int blocksize=int(globals[$(blocksize_index)]);
#! } else {
  int blocksize=240;
#! }

#! int chunk_index=unchecked_global_index_of("chunk");
#! if (chunk_index != -1) {
  int chunk=int(globals[$(chunk_index)]);
#! } else {
  int chunk=100*blocksize;
#! }
  if (chunk > n) chunk=n;
  Vec<$(type)> vecglobals($(nglobals()),blocksize);
  Vec<$(type)> vecparameters($(nparameters())*chunk,blocksize);
  Vec<$(type)> vecx($(nvariables())*chunk,blocksize);

  for (int k=0; k<$(nglobals()); ++k) vecglobals[k]=globals[k];
  for (int k=0; k<n; k+=chunk) {
    int m=chunk;
    if (k+m > n) m=n-k;
    for (int el=0; el<m; ++el) {
       for (int elp=0; elp<$(nparameters()); ++elp) { vecparameters[$(nparameters())*el+elp]=parameters[$(nparameters())*(k+el)+elp]; }
       for (int elx=0; elx<$(nvariables()); ++elx) { vecx[$(nvariables())*el+elx]=x[$(nvariables())*(k+el)+elx]; }
    }
    dim3 block(blocksize,1,1);
    dim3 grid(ceildiv(m,blocksize),1,1);
    $(prefix)cuda_solve<<<grid,block>>>(chunk,vecglobals.dev_data(),m,vecparameters.dev_data(),vecx.dev_data());
    cutilSafeCall(cudaThreadSynchronize());
    for (int el=0; el<m; ++el) {
       for (int elx=0; elx<$(nvariables()); ++elx) { x[$(nvariables())*(k+el)+elx]=vecx[$(nvariables())*el+elx]; }
       for (int elp=0; elp<$(nparameters()); ++elp) { 
         parameters[$(nparameters())*(k+el)+elp]=vecparameters[$(nparameters())*el+elp]; 
       }
    }
  }
}
#!  } // define_host_solve()
#!
#!  void prototype_device_update(const std::string &end="")
#!  {
__device__ void $(prefix)update(
  int $(prefix)chunk,int $(prefix)cell,
  const $(type) $(prefix)globals[$(nglobals())],
  $(type) *$(prefix)parameters,
  const $(type) *$(prefix)x
)$(end)
#!  }
#!
#!  void define_device_update()
#!  {
#!prototype_device_update();
{
#!    FOREACH_UPDATE(k) {
#!      Expression *xk = parse(k->first);
#!      Expression *uk = parse(k->second);
$(format(xk))=$(format(uk));
#!      delete uk;
#!      delete xk;
#!    }
} // __device__ $(prefix)update()
#!  }
#!
#!  void prototype_global_update(const std::string &end="")
#!  {
__global__ void $(prefix)cuda_update(
  int chunk,
  $(type) *globals,
  int n,
  $(type) *parameters,
  const $(type) *x
)$end
#!  }
#!
#!  void define_global_update()
#!  {
#!    prototype_global_update();
{
  int i = blockIdx.x*blockDim.x + threadIdx.x;
  if (i < n) {
    $(prefix)update(chunk,i,globals,&parameters[i*$(nparameters())],&x[i*$(nvariables())]);
  }
} // __global__ $(prefix)cuda_update()
#!  }
#!
#!  void prototype_host_update(const std::string &end="")
#!  {
void $(prefix)update(
  const $(type) *globals, 
  int n,
  $(type) *parameters
)$end
#!  }
#!
#!  void define_host_update()
#!  {
#!     prototype_host_update();
{
#! int blocksize_index=unchecked_global_index_of("blocksize");
#! if (blocksize_index != -1) {
  int blocksize=int(globals[$(blocksize_index)]);
#! } else {
  int blocksize=240;
#! }

#! int chunk_index=unchecked_global_index_of("chunk");
#! if (chunk_index != -1) {
  int chunk=int(globals[$(chunk_index)]);
#! } else {
  int chunk=blocksize*100;
#! }
  if (chunk > n) chunk=n;
  Vec<$(type)> vecglobals($(nglobals()),blocksize);
  Vec<$(type)> vecparameters($(nparameters())*chunk,blocksize);
  Vec<$(type)> vecx($(nvariables())*chunk,blocksize);

  for (int k=0; k<$(nglobals()); ++k) vecglobals[k]=globals[k]; // here the globals are moved to pinned memory.
  for (int k=0; k<n; k+=chunk) {
    int m=chunk;
    if (k+m > n) m=n-k;
    for (int el=0; el<m; ++el) {
       for (int elp=0; elp<$(nparameters()); ++elp) { vecparameters[$(nparameters())*el+elp]=parameters[$(nparameters())*(k+el)+elp]; }
    }
    dim3 block(blocksize,1,1);
    dim3 grid(ceildiv(m,blocksize),1,1);
    $(prefix)cuda_solve<<<grid,block>>>(chunk,vecglobals.dev_data(),m,
                                        vecparameters.dev_data(),vecx.dev_data());
    cutilSafeCall(cudaThreadSynchronize());

#!    if (unchecked_parameter_index_of("scalar_residual") != -1) {
    $(type) scalar_residual[$(nequations())];

    for (int el=0; el<m; ++el) {
      $(prefix)scalarf(chunk,el,&vecglobals[0],&vecparameters[0],&vecx[0],scalar_residual);
      vecparameters[$(nparameters())*el + $(parameter_index_of("scalar_residual"))]=$(prefix)norm($(nequations()),scalar_residual);
    }
#!  }
    $(prefix)cuda_update<<<grid,block>>>(chunk,vecglobals.dev_data(),m,
                                         vecparameters.dev_data(),vecx.dev_data());
    cutilSafeCall(cudaThreadSynchronize());
    for (int el=0; el<m; ++el) {
       for (int elp=0; elp<$(nparameters()); ++elp) { 
         parameters[$(nparameters())*(k+el)+elp]=vecparameters[$(nparameters())*el+elp]; 
       }
    }
  }
} // $(prefix)update()
#!  }
#!
#!  std::string numeric_values(Configuration::Case &c, std::list < std::string > &group) {
#!    std::ostringstream oss;
#!    oss << "{";
#!    for (std::list < std::string > :: iterator i = group.begin(); i!=group.end(); ++i) {
#!      if (i != group.begin()) { oss << ","; }
#!      std::list < std::pair < std::string , double > > :: iterator j=c.setup.begin();
#!      while (j != c.setup.end()) {
#!        if (*i == j->first) break;
#!        ++j;
#!      }
#!      oss << "/* " << *i << "= */ " << std::setprecision(15) 
#!         << ((j != c.setup.end() ) ? j->second : 0.0);
#!    }
#!    oss << "}";
#!    return oss.str();
#!  }
#!
#!  void prototype_names(const std::string &end="")
#!  {
enum { $(prefix)global_count=$(nglobals()) };
extern const char *$(prefix)global_names[$(nglobals())];

enum { $(prefix)parameter_count=$(nparameters()) };
extern const char *$(prefix)parameter_names[$(nparameters())];

enum { $(prefix)variable_count=$(nvariables()) };
extern const char *$(prefix)variable_names[$(nvariables())];
#!  }
#!
#!  void define_names()
#!  {
const char *$(prefix)global_names[]={
#!{int count=0, last=nglobals()-1; FOREACH_GLOBAL(j) {
  $(encode_string_always(*j))$((count != last)?",":"")
#! ++count;}}
};

const char *$(prefix)parameter_names[]={
#!{int count=0, last=nparameters()-1; FOREACH_PARAMETER(j) {
  $(encode_string_always(*j))$((count != last)?",":"")
#! ++count;}}
};

const char *$(prefix)variable_names[]={
#! {int count=0, last=nvariables()-1; FOREACH_VARIABLE(j) {
  $(encode_string_always(*j))$((count != last)?",":"")
#! ++count; }}
};

#!  }
#!
#!  void prototype_host_tests(const std::string &end="")
#!  {
void $(prefix)tests(const std::string &name)$(end)
#!  }
#!
#!  void define_host_tests()
#!  {
typedef struct {
  const char *name;
  $(type) globals[$(nglobals())];
  $(type) parameters[$(nparameters())];
  $(type) x[$(nvariables())];
} $(prefix)test_data_t;

$(prefix)test_data_t $(prefix)test_data[] = {
#!  {int count=1; FOREACH_TEST(k) {
#!    Configuration::Case &c=*k;
#!    if (count != 1) { *out << "," << endl; }
  { /* test case $count */
    /* name= */ "$(c.name)",
    $(numeric_values(c,configuration->globals)),
    $(numeric_values(c,configuration->parameters)),
    $(numeric_values(c,configuration->variables))
  }$
#!  ++count; }}
}; // $(prefix)test_data
#!    
#!prototype_host_tests();
{
  std::string case_name;
  std::string max_x_error_name="none";
  int max_x_error_count=0;
  $(type) max_x_error=0;
  $(type) x_error=0;
  std::string max_y_error_name="none";
  int max_y_error_count=0;
  $(type) max_y_error=0;
  $(type) y_error=0;

  $(type) x_test[$(dim)];
  $(type) y_test[$(dim)];

  for (int case_count=0; case_count < $(ntests()); ++case_count) {
    if (name == "all" || name == $(prefix)test_data[case_count].name) {
       const char *name=$(prefix)test_data[case_count].name;
       $(type) *globals=$(prefix)test_data[case_count].globals;
       $(type) *parameters=$(prefix)test_data[case_count].parameters;
       $(type) *x=$(prefix)test_data[case_count].x;

       $(prefix)solve(globals,1,parameters,x_test);
       $(prefix)f(globals,1,parameters,x_test,y_test);
       x_error=$(prefix)dist($dim,x,x_test);
       y_error=$(prefix)norm($dim,y_test);

       if (x_error > max_x_error) {
         max_x_error=x_error;
         max_x_error_name=name;
         max_x_error_count=case_count;
       }

       if (y_error > max_y_error) {
         max_y_error=y_error;
         max_y_error_name=name;
         max_y_error_count=case_count;
       }

       std::cout << "test " << (case_count+1) << "/" << "\"" << name << "\"" << ": " << "x_error=" << std::setprecision(15) << x_error << "," << "y_error=" << std::setprecision(15) << y_error << std::endl;
     }
   }
   if (name == "all") {
     std::cout << "test summary: " 
       << "max_x_error=" << std::setprecision(15) << max_x_error
          << " from " << max_x_error_count << "/" 
          << "\"" << max_x_error_name << "\""
       << ","
       << "max_y_error=" << std::setprecision(15) << max_y_error
          << " from " << max_y_error_count << "/" 
          << "\"" << max_y_error_name << "\""
       << std::endl;
   }
}
#!  }
#!
#!
#!  void prototype_host_runs(const std::string &end="")
#!  {
void $(prefix)runs(const std::string &name)$end
#!  }
#!
#!  void define_host_runs()
#!  {
typedef struct {
  const char *name;
  $(type) globals[$(nglobals())];
  $(type) parameters[$(nparameters())];
} $(prefix)run_data_t;

$(prefix)run_data_t $(prefix)run_data[] = {
#!  {int count=1; FOREACH_RUN(k) {
#!    Configuration::Case &c=*k;
#!    if (count != 1) { *out << "," << endl; }
  { /* run case $count */
    /* name= */ "$(c.name)",
    $(numeric_values(c,configuration->globals)),
    $(numeric_values(c,configuration->parameters)),
  }$
#!  ++count; }}
}; // $(prefix)run_data
#!    
#!prototype_host_runs();
{
    if (name == "parallel") {
      const $(type) *globals;

      int case_count=0;
      while (case_count < $(nruns())) {
         globals=$(prefix)run_data[case_count].globals;
         int dup_globals=1;
         for (;;) {
            if (case_count + dup_globals >= $(nruns())) break;
            bool same=true;
	    for (int k=0; k<$(nglobals()); ++k) 
              if (globals[k] !=
                  $(prefix)run_data[case_count+dup_globals].globals[k]) { 
                 same=false; break; 
              }
	    if (!same) break;
	    ++dup_globals;
         }
         $(type) *parameters = new $(type)[$(nparameters())*dup_globals];
         $(type) *vars = new $(type)[$(nvariables())*dup_globals];
         for (int j=0; j<dup_globals; ++j) {
	    for (int k=0; k<$(nparameters()); ++k) {
              parameters[$(nparameters())*j+k]=$(prefix)run_data[case_count+j].parameters[k];
            }
         }
         $(prefix)solve(globals,dup_globals,parameters,vars);

#! if (flag("quiet_run") != "true") {

	 std::cout << "# " << dup_globals << " jobs in parallel follows." << std::endl;
         for (int k=0; k<dup_globals; ++k) {

           std::cout << "[case] # " << (case_count+1) << " (parallel task # " << k << ")" << std::endl;
           std::cout << "name=\"" << $(prefix)run_data[case_count+k].name << "\"" << std::endl;

           for (int i=0; i<$(prefix)global_count; ++i) {
             std::cout << $(prefix)global_names[i] << "=" << std::setprecision(15) << globals[i] << std::endl;
           }

           for (int i=0; i<$(prefix)parameter_count; ++i) {
             std::cout << $(prefix)parameter_names[i] << "=" << std::setprecision(15) << parameters[$(prefix)parameter_count*k+i] << std::endl;
           }

           for (int i=0; i<$(prefix)variable_count; ++i) {
             std::cout << $(prefix)variable_names[i] << "=" << std::setprecision(15) << vars[$(prefix)variable_count*k+i] << std::endl;
           }
         }

#! } // not quiet_run

	 delete [] parameters;
	 delete [] vars;

         case_count += dup_globals;
      }
   
    } else {
    std::string case_name;
    for (int case_count=0; case_count < $(nruns()); ++case_count) {
      if (name == "all" || name == $(prefix)run_data[case_count].name) {
        const char *case_name=$(prefix)run_data[case_count].name;
        $(type) *globals=$(prefix)run_data[case_count].globals;
        $(type) *parameters=$(prefix)run_data[case_count].parameters;
        $(type) x[$(dim)];
  
        $(prefix)solve(globals,1,parameters,x);

#! if (flag("quiet_run") != "true") {

        std::cout << "[case] # " << (case_count+1) << std::endl;
        std::cout << "name=\"" << case_name << "\"" << std::endl;

      for (int i=0; i<$(prefix)global_count; ++i) {
        std::cout << $(prefix)global_names[i] << "=" << std::setprecision(15) << globals[i] << std::endl;
      }

      for (int i=0; i<$(prefix)parameter_count; ++i) {
        std::cout << $(prefix)parameter_names[i] << "=" << std::setprecision(15) << parameters[i] << std::endl;
      }

      for (int i=0; i<$(prefix)variable_count; ++i) {
        std::cout << $(prefix)variable_names[i] << "=" << std::setprecision(15) << x[i] << std::endl;
      }

#! } // if not quiet_run
      }
    }
  }
} // $(prefix)runs()
#!  }
#!
#!  void prototype_main(const std::string &end="")
#!  {
int main(int argc, char *argv[])$(end)
#!  }
#!
#!  void define_main()
#!  {
#!    prototype_main();
{
  cudautil::CUDAContext cuda(argc,argv);
  cuda.requireCanMapHostMemory();
#!if (precision == "double") {
  cuda.requireDoublePrecision();
#!}

  $(flag("namespace"))::$(prefix)Stopwatch timer;
  timer.start();
  for (int argi=1; argi<argc; ++argi) {
    std::string arg=argv[argi];

    if (arg == "-tests") {
      $(flag("namespace"))::$(prefix)tests("all"); 
      continue; 
    }
    if (arg == "-runs") {
      $(flag("namespace"))::$(prefix)runs("all"); 
      continue; 
    }
    if (arg == "-test") {
      $(flag("namespace"))::$(prefix)tests(argv[++argi]);
      continue;
    }
    if (arg == "-run") {
      $(flag("namespace"))::$(prefix)runs(argv[++argi]);
      continue;
    }
    if (arg != "-h") {
      std::cout << "unknown arg " << arg << std::endl;
    }
    std::cout << "usage: " << argv[0] << " [-h] [-tests] [-runs] [-test <case> ...] [-run <case> ...]" << std::endl;
    std::cout << "test cases:";
    for (int test_count=0; test_count<$(ntests()); ++test_count) {
      std::cout << " \"" << $(flag("namespace"))::$(prefix)test_data[test_count].name << "\"";
    }
    std::cout << std::endl;
    std::cout << "run cases:";
    for (int run_count=0; run_count<$(nruns()); ++run_count) {
      std::cout << " \"" << $(flag("namespace"))::$(prefix)run_data[run_count].name << "\"";
    }
    std::cout << std::endl;
  }
  timer.stop();
  std::cout << "Time elapsed in seconds: " << timer.time() << std::endl;
  return 0;
} // main()
#!  }
#!
#!  void generate_cuda_header()
#!  {
#!    string file_hpp=file;
#!    if (!endswith(file,".hu")) {
#!      file_hpp += ".hu";
#!    }
#!    ofstream outfile(file_hpp.c_str());
#!    out=&outfile;
#!    if (!*out) {
#!      cerr << "cudacodegenerator: could not write to configured header file " << encode_string(file) << endl;
#!      return;
#!    }
#!
#ifndef $(toupper(flag("namespace")))_$(toupper(prefix))SOLVE_HU
#define $(toupper(flag("namespace")))_$(toupper(prefix))SOLVE_HU
#!
#!    begin_namespace();
#!
#!    prototype_names(";");
#!
#!    linearAlgebra.target="__host__";
#!    linearAlgebra.prefix=prefix;
#!    linearAlgebra.prototype_norm2(";");
#!    linearAlgebra.prototype_norm(";");
#!    linearAlgebra.prototype_dist2(";");
#!    linearAlgebra.prototype_dist(";");
#!
#!    linearAlgebra.target="__device__";
#!    linearAlgebra.prefix=prefix+"cuda";
#!    linearAlgebra.prototype_all();
#!

// __device__ functions must be available inline...

#!    linearAlgebra.define_all();
#!
#!    prototype_scalar_function(";");
#!    prototype_device_function(";");
#!    prototype_global_function(";");
#!    prototype_host_function(";");
#!    prototype_device_jacobian(";");
#!    prototype_device_initialize(";");
#!    prototype_device_solve(";");
#!    prototype_global_solve(";");
#!    prototype_host_solve(";");
#!    prototype_device_update(";");
#!    prototype_global_update(";");
#!    prototype_host_update(";");
#!    prototype_host_tests(";");
#!    prototype_host_runs(";");
#!
#!    end_namespace();
#!
#!    if (flag("main") == "true") {
#!      prototype_main(";");
#!    }
#!

#endif
#!  }
#!  void generate_header()
#!  {
#!    string file_hpp=file;
#!    if (!endswith(file,".h")) {
#!      file_hpp += ".h";
#!    }
#!    ofstream outfile(file_hpp.c_str());
#!    out=&outfile;
#!    if (!*out) {
#!      cerr << "cudacodegenerator: could not write to configured header file " << encode_string(file) << endl;
#!      return;
#!    }
#!
#ifndef $(toupper(flag("namespace")))_$(toupper(prefix))SOLVE_H
#define $(toupper(flag("namespace")))_$(toupper(prefix))SOLVE_H
#!
#!    begin_namespace();
#!
#!    prototype_names(";");
#!
#!    linearAlgebra.target="";
#!    linearAlgebra.prefix=prefix;
#!    linearAlgebra.prototype_norm2(";");
#!    linearAlgebra.prototype_norm(";");
#!    linearAlgebra.prototype_dist2(";");
#!    linearAlgebra.prototype_dist(";");
#!
#!
#!    prototype_host_function(";");
#!    prototype_host_solve(";");
#!    prototype_host_update(";");
#!    prototype_host_tests(";");
#!    prototype_host_runs(";");
#!
#!    end_namespace();
#!
#!    if (flag("main") == "true") {
#!      prototype_main(";");
#!    }
#!

#endif
#!  }
#!
#!  void define_aliases()
#!  {
#!    int count;
#!
#!    o() << "// global aliases" << endl;
#!    { int count=0; FOREACH_GLOBAL(i) {
#!      o() << "#define " << format(*i) << " " << prefix << "globals[" << count << "]" << endl;
#!      ++count; 
#!      }}
#!    o() << endl;
#!
#!    o() << "// parameter aliases" << endl;
#!    { int count=0; FOREACH_PARAMETER(i) {
#!      o() << "#define " << format(*i) << " " << prefix << "parameters[" << count << "]" << endl;
#!      ++count;
#!      }}
#!    o() << endl;
#!
#!    o() << "// variable aliases" << endl;
#!    { int count=0; FOREACH_VARIABLE(i) {
#!      o() << "#define " << format(*i) << " " << prefix << "x[" << count << "]" << endl;
#!      ++count;
#!      }}
#!    o() << endl;
#!
#!    o() << "// residual aliases" << endl;
#!    { int count=0; FOREACH_EQUATION(i) {
#!      o() << "#define " << format(i->first) << " " << prefix << "y[" << count << "]" << endl;
#!      ++count;
#!      }}
#!    o() << endl;
#!
#!    o() << "// jacobian aliases (fortran order)" << endl;
#!    { int icount=0; FOREACH_EQUATION(i) {
#!      { int jcount=0; FOREACH_VARIABLE(j) {
#!          o() << "#define " << "d" << format(i->first) << "_d" << format(*j) << " " << prefix << "dy[" << (dim*jcount+icount) << "]" << endl;
#!          ++jcount;
#!        }}
#!      ++icount;
#!      }}
#!    o() << endl;
#!
#!  }
#!
#!  void includes()
#!  {
#include "math.h"
#include <iostream>
#include <iomanip>
#include <sys/time.h>

#include <assert.h>
#include "cudautil.hu"
#include "cudavec.hu"
#!   string header=flag("file");
#!   if (header.rfind("/") != -1) header=header.substr(header.rfind("/")+1);
#!   if (header.rfind(".") != -1) header=header.substr(0,header.rfind("."));
#!   header=header+".hu";
#include "$(header)"

// using namespace cudalinearalgebra;
#!  }
#!
#!  void define_stopwatch()
#!  {
class $(prefix)Stopwatch
{
public:
  struct timeval startTime, endTime, diffTime;
  void start() {
    gettimeofday(&startTime,NULL);
  }
  void stop() {
    gettimeofday(&endTime,NULL);
    timersub(&endTime,&startTime,&diffTime);
  }
  double time()
  {
    return diffTime.tv_sec + 1e-6*diffTime.tv_usec;
  }
};
#!  }
#!
#!  void generate_source()
#!  {
#!    string file_cpp=file;
#!    if (!endswith(file,".cu")) {
#!      file_cpp += ".cu";
#!    }
#!    ofstream outfile(file_cpp.c_str());
#!    out=&outfile;
#!    if (!*out) {
#!      cerr << "cudacodegenerator: could not write to configured source file " << encode_string(file) << endl;
#!      return;
#!    }
#!    includes();
#!
#!    begin_namespace();
#!
#!    define_names();
#!
#!    define_stopwatch();
#!
#!    linearAlgebra.target="__host__";
#!    linearAlgebra.prefix=prefix;
#!    linearAlgebra.define_norm2();
#!    linearAlgebra.define_norm();
#!    linearAlgebra.define_dist2();
#!    linearAlgebra.define_dist();
#!
#!    define_inline();
#!    define_global_function();
#!    define_host_function();
#!    define_global_solve();
#!    define_host_solve();
#!    define_global_update();
#!    define_host_update();
#!    define_host_tests();
#!    define_host_runs();
#!    define_device_solve(); // no deps on aliases
#!
#!    define_aliases();
#!    define_scalar_function();
#!    define_device_function();
#!    define_device_jacobian();
#!    define_device_initialize();
#!    define_device_update();
#!
#!    end_namespace();
#!
#!    if (flag("main") == "true") {
#!      define_main();
#!    }
#!
#!  }
#!
#!  
#!  void generate()
#!  {
#!#ifdef SYMBOLIC_OUT_MODE
#!    if (precision == "single"){
#!      Expression::outMode=Expression::OUT_MODE_C_SINGLE;
#!    }
#!    else {
#!      Expression::outMode=Expression::OUT_MODE_C_DOUBLE;
#!    }
#!#endif
#!    if (mode & SOURCE) {
#!      generate_source();
#!    }
#!
#!    if (mode & HEADER) {
#!      generate_header();
#!    }
#!
#!    if (mode & CUDA_HEADER) {
#!      generate_cuda_header();
#!    }
#!  }
#!};
#!
#!class CudaRegister {
#!public:
#!  CudaRegister()
#!  {
#!    CodeGenerator *generator = new CudaCodeGenerator();
#!    CodeGenerator::registry_add("cuda",generator);
#!    CodeGenerator::registry_add("cu",generator);
#!  }
#!};
#!
#!static const CudaRegister CUDA_REGISTER;
#!
#!}
